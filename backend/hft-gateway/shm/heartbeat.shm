// src/shm_heartbeat_demo.cpp
// Produce or watch a /heartbeat shm segment.
// Build: add target in CMakeLists (see snippet below).
// Run:   ./shm_heartbeat_demo prod   # producer: updates every 1s
//        ./shm_heartbeat_demo watch  # watcher: prints status

#include <chrono>
#include <cstring>
#include <iostream>
#include <thread>

#include "shared_memory.hpp"   // shm::MappedRegion
#include "shm_layouts.hpp"     // shm_layout::Heartbeat

using clock_t = std::chrono::steady_clock;

static inline uint64_t now_ns() {
  return static_cast<uint64_t>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          clock_t::now().time_since_epoch()).count());
}

int main(int argc, char** argv) {
  if (argc < 2) {
    std::cerr << "usage: " << argv[0] << " [prod|watch]\n";
    return 1;
  }
  std::string mode = argv[1];

  const std::size_t BYTES = sizeof(shm_layout::Heartbeat);
  if (mode == "prod") {
    // Producer: create or open heartbeat region, then update in a loop.
    auto reg = shm::MappedRegion::open_or_create("/heartbeat", BYTES, shm::Access::ReadWrite);
    auto* hb  = reinterpret_cast<shm_layout::Heartbeat*>(reg.addr());

    // If this is a fresh region, zero & set sane defaults.
    // Heuristic: flags==garbage on fresh mmap; we just zero the whole struct.
    std::memset(hb, 0, sizeof(*hb));
    hb->alive.store(1, std::memory_order_release);
    hb->flags.store(0, std::memory_order_release);

    std::cout << "[producer] updating /heartbeat every 1s. Ctrl+C to stop.\n";
    while (true) {
      hb->ts_ns.store(now_ns(), std::memory_order_release);
      hb->alive.store(1, std::memory_order_release);
      // Optionally set bits in flags (e.g., bit0=MD ok, bit1=TX ok)
      // hb->flags.store(0b11, std::memory_order_release);
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }

  } else if (mode == "watch") {
    // Watcher: open existing heartbeat read-only and poll.
    try {
      auto reg = shm::MappedRegion::open_existing("/heartbeat", BYTES, shm::Access::ReadOnly);
      auto* hb = reinterpret_cast<shm_layout::Heartbeat*>(reg.addr());
      std::cout << "[watch] reading /heartbeatâ€¦ (Ctrl+C to quit)\n";
      while (true) {
        uint64_t ts = hb->ts_ns.load(std::memory_order_acquire);
        uint32_t ok = hb->alive.load(std::memory_order_acquire);
        uint32_t fl = hb->flags.load(std::memory_order_acquire);

        // Simple freshness check: consider stale if > 3 seconds old
        uint64_t age_ns = now_ns() - ts;
        double age_ms = static_cast<double>(age_ns) / 1e6;

        std::cout << "alive=" << ok
                  << " flags=0x" << std::hex << fl << std::dec
                  << " age_ms=" << age_ms << "\n";

        std::this_thread::sleep_for(std::chrono::milliseconds(500));
      }
    } catch (const std::exception& e) {
      std::cerr << "failed to open /heartbeat: " << e.what() << "\n";
      return 2;
    }

  } else {
    std::cerr << "unknown mode: " << mode << " (use prod|watch)\n";
    return 1;
  }
}