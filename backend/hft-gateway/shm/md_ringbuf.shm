// src/shm_md_ringbuf_demo.cpp
// Produce or watch a /md_ringbuf shm: QuoteMsg ring buffer.
//
// Build: add target in CMakeLists (snippet below).
// Run : ./shm_md_ringbuf_demo prod   # producer: writes quotes @ ~1 kHz
//       ./shm_md_ringbuf_demo watch  # watcher: reads & prints quotes

#include <chrono>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>

#include "shared_memory.hpp"   // shm::MappedRegion
#include "shm_layouts.hpp"     // shm_layout::{RingBufHdr, QuoteMsg}

using clock_t = std::chrono::steady_clock;

static inline uint64_t now_ns() {
  return static_cast<uint64_t>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(
        clock_t::now().time_since_epoch()).count());
}

namespace ipc {

// Minimal SPSC ring over a mapped region (Header + slots[T])
template <typename T>
class ShmRing {
public:
  static ShmRing open_or_create(const std::string& name, uint32_t capacity) {
    const std::size_t bytes = sizeof(shm_layout::RingBufHdr) + capacity * sizeof(T);
    auto reg = shm::MappedRegion::open_or_create(name, bytes, shm::Access::ReadWrite);

    auto* hdr = reinterpret_cast<shm_layout::RingBufHdr*>(reg.addr());
    if (hdr->capacity == 0 || hdr->elem_size != sizeof(T)) {
      std::memset(reg.addr(), 0, reg.size());
      hdr->head.store(0, std::memory_order_relaxed);
      hdr->tail.store(0, std::memory_order_relaxed);
      hdr->capacity = capacity;
      hdr->elem_size = sizeof(T);
    }
    auto* slots = reinterpret_cast<T*>(reinterpret_cast<std::uint8_t*>(reg.addr()) + sizeof(shm_layout::RingBufHdr));
    return ShmRing(std::move(reg), hdr, slots);
  }

  static ShmRing open_existing(const std::string& name, uint32_t capacity, shm::Access acc = shm::Access::ReadOnly) {
    const std::size_t bytes = sizeof(shm_layout::RingBufHdr) + capacity * sizeof(T);
    auto reg = shm::MappedRegion::open_existing(name, bytes, acc);
    auto* hdr = reinterpret_cast<shm_layout::RingBufHdr*>(reg.addr());
    auto* slots = reinterpret_cast<T*>(reinterpret_cast<std::uint8_t*>(reg.addr()) + sizeof(shm_layout::RingBufHdr));
    return ShmRing(std::move(reg), hdr, slots);
  }

  bool push(const T& v) {
    const uint32_t cap  = hdr_->capacity;
    const uint32_t head = hdr_->head.load(std::memory_order_relaxed);
    const uint32_t next = (head + 1) % cap;
    if (next == hdr_->tail.load(std::memory_order_acquire)) return false; // full
    slots_[head] = v;
    hdr_->head.store(next, std::memory_order_release);
    return true;
  }

  bool pop(T& out) {
    const uint32_t cap  = hdr_->capacity;
    const uint32_t tail = hdr_->tail.load(std::memory_order_relaxed);
    if (tail == hdr_->head.load(std::memory_order_acquire)) return false; // empty
    out = slots_[tail];
    hdr_->tail.store((tail + 1) % cap, std::memory_order_release);
    return true;
  }

private:
  ShmRing(shm::MappedRegion&& reg, shm_layout::RingBufHdr* hdr, T* slots)
    : reg_(std::move(reg)), hdr_(hdr), slots_(slots) {}
  shm::MappedRegion reg_;
  shm_layout::RingBufHdr* hdr_;
  T* slots_;
};

} // namespace ipc

int main(int argc, char** argv) {
  if (argc < 2) {
    std::cerr << "usage: " << argv[0] << " [prod|watch]\n";
    return 1;
  }
  std::string mode = argv[1];
  constexpr uint32_t CAPACITY = 1u << 14; // 16384 quotes

  if (mode == "prod") {
    auto rb = ipc::ShmRing<shm_layout::QuoteMsg>::open_or_create("/md_ringbuf", CAPACITY);
    std::cout << "[producer] writing quotes to /md_ringbuf (Ctrl+C to stop)\n";

    const char* syms[] = {"AAPL","MSFT","TSLA","SBIN","RELIANC"};
    size_t nsyms = sizeof(syms)/sizeof(syms[0]);
    double base[] = {200.0, 410.0, 250.0, 800.0, 2900.0};

    size_t i = 0;
    while (true) {
      shm_layout::QuoteMsg q{};
      std::memset(&q, 0, sizeof(q));
      std::strncpy(q.sym, syms[i % nsyms], sizeof(q.sym));
      double b = base[i % nsyms];
      double tick = 0.01 * ((i % 7) - 3);
      q.bid = b + tick;
      q.ask = q.bid + 0.02;
      q.ts_ns = now_ns();

      if (!rb.push(q)) {
        // backoff if full
        std::this_thread::sleep_for(std::chrono::microseconds(50));
      }
      ++i;
      // ~1kHz per symbol
      std::this_thread::sleep_for(std::chrono::microseconds(1'000));
    }

  } else if (mode == "watch") {
    try {
      auto rb = ipc::ShmRing<shm_layout::QuoteMsg>::open_existing("/md_ringbuf", CAPACITY, shm::Access::ReadOnly);
      std::cout << "[watch] reading /md_ringbuf (Ctrl+C to quit)\n";
      shm_layout::QuoteMsg q{};
      while (true) {
        int drained = 0;
        while (rb.pop(q)) {
          std::cout << q.sym << " bid=" << q.bid << " ask=" << q.ask << " ts=" << q.ts_ns << "\n";
          if (++drained >= 50) break; // don't spam too hard
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
      }
    } catch (const std::exception& e) {
      std::cerr << "failed to open /md_ringbuf: " << e.what() << "\n";
      return 2;
    }
  } else {
    std::cerr << "unknown mode: " << mode << " (use prod|watch)\n";
    return 1;
  }
}