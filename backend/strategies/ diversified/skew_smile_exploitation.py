# backend/strategies/diversified/skew_smile_exploitation.py
from __future__ import annotations

import json, math, os, time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import redis
from backend.engine.strategy_base import Strategy

"""
Skew/Smile Exploitation — paper
-------------------------------
Two trade templates:

1) BUTTERFLY_SMILE
   • Fit a quadratic in log-moneyness y = a + b*m + c*m^2 to the IV smile for expiry T
   • Find strikes with residual > THRESH_IV_BPS (in vol bp). If point is rich, SELL center via short fly
     (short 2x center, long 1x each wing). If cheap, BUY long fly.
   • Target vega-neutral (approx) using Black ’76 vegas.

2) RISK_REVERSAL_SKEW
   • Compare current 25Δ RR (σ_put25 - σ_call25) to a baseline (rolling mean) from Redis.
   • If |deviation| > THRESH_RR_BPS, trade a delta-hedged RR (buy/sell 25Δ put vs call).
   • Optional vega hedge: add a small ATM straddle leg.

Redis feeds you publish elsewhere:
  # IV surface per expiry (simple compact form)
  HSET iv:surface:<SYM>:<EXP_DAYS> data '{"strikes":[K1,...], "iv":[σ1,...]}'   # IV in decimals
  HSET opt:meta:<SYM>  '{"spot": S, "r": r, "q": q}'   # spot, rate, div (annualized decimals)

  # Per-strike quotes are optional (module trades at 'mid' IV using paper symbols)
  # If you do provide quotes, module can switch to executable mid/edge.

  # RR baseline (bps)
  HSET iv:rr:baseline:<SYM> '<EXP_DAYS>' <bps>   # rolling mean 25Δ RR in vol bps

  # Ops
  SET risk:halt 0|1

Paper routing (map in adapters):
  • Calls: "OPT_CALL:<SYM>:<K>:<EXP_DAYS>"
  • Puts : "OPT_PUT:<SYM>:<K>:<EXP_DAYS>"
  side in {"buy","sell"}, order_type="market"/"limit", qty in contracts
"""

# ============================ CONFIG ============================
REDIS_HOST = os.getenv("SS_REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("SS_REDIS_PORT", "6379"))

SYM       = os.getenv("SS_SYMBOL", "SPY").upper()
EXP_DAYS  = int(os.getenv("SS_EXP_DAYS", "30"))
MODE      = os.getenv("SS_MODE", "BUTTERFLY_SMILE").upper()   # BUTTERFLY_SMILE | RISK_REVERSAL_SKEW

# Thresholds (in **vol basis points** where 100 bps = 1 vol point)
THRESH_IV_BPS   = float(os.getenv("SS_THRESH_IV_BPS", "80"))     # smile residual trigger
EXIT_IV_BPS     = float(os.getenv("SS_EXIT_IV_BPS",   "30"))
THRESH_RR_BPS   = float(os.getenv("SS_THRESH_RR_BPS", "80"))     # RR deviation vs baseline
EXIT_RR_BPS     = float(os.getenv("SS_EXIT_RR_BPS",   "30"))
ENTRY_Z         = float(os.getenv("SS_ENTRY_Z", "1.1"))
EXIT_Z          = float(os.getenv("SS_EXIT_Z",  "0.5"))

# Sizing / risk
USD_NOTIONAL      = float(os.getenv("SS_USD_NOTIONAL", "25000"))
MIN_TICKET_USD    = float(os.getenv("SS_MIN_TICKET_USD", "300"))
CONTRACT_MULT     = float(os.getenv("SS_CONTRACT_MULT", "100"))  # equity options = 100 shares/contract
MAX_CONCURRENT    = int(os.getenv("SS_MAX_CONCURRENT", "2"))

# Cadence
RECHECK_SECS      = float(os.getenv("SS_RECHECK_SECS", "1.0"))
EWMA_ALPHA        = float(os.getenv("SS_EWMA_ALPHA", "0.08"))

# Redis keys
SURF_HK        = os.getenv("SS_SURF_HK", "iv:surface:{sym}:{exp}")
META_HK        = os.getenv("SS_META_HK", "opt:meta:{sym}")
RR_BASE_HK     = os.getenv("SS_RR_BASE_HK", "iv:rr:baseline:{sym}")
HALT_KEY       = os.getenv("SS_HALT_KEY", "risk:halt")

# ============================ Redis ============================
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

# ============================ Black '76 helpers ============================
def _norm_cdf(x: float) -> float:
    return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))

def _black_vega(S: float, K: float, T: float, r: float, q: float, sigma: float, is_call: bool=True) -> float:
    if sigma <= 0 or T <= 0 or S <= 0 or K <= 0: return 0.0
    f = S * math.exp((r - q) * T)
    vol = sigma * math.sqrt(T)
    d1 = (math.log(f / K) + 0.5 * sigma * sigma * T) / max(1e-12, vol)
    # Vega on forward (per 1 vol point = 0.01), return in $ per 1.0 (=100 vol pts)
    return math.exp(-r * T) * f * math.exp(-0.5 * d1 * d1) / math.sqrt(2 * math.pi)

def _T(exp_days: int) -> float:
    return max(1.0/365.0, exp_days / 365.0)

# ============================ IO helpers ============================
def _hget_json(hk: str, field: str) -> Optional[dict]:
    raw = r.hget(hk, field)
    if not raw: return None
    try:
        j = json.loads(raw) # type: ignore
        return j if isinstance(j, dict) else None
    except Exception:
        return None

def _surf(sym: str, exp_days: int) -> Optional[Tuple[List[float], List[float]]]:
    j = _hget_json(SURF_HK.format(sym=sym, exp=exp_days), "data")
    if not j: return None
    K = [float(x) for x in (j.get("strikes") or [])]
    V = [float(x) for x in (j.get("iv") or [])]
    if len(K) >= 5 and len(K) == len(V):
        return K, V
    return None

def _meta(sym: str) -> Optional[Tuple[float,float,float]]:
    j = _hget_json(META_HK.format(sym=sym), sym) or _hget_json(META_HK.format(sym=sym), "meta")
    if not j: return None
    try:
        S = float(j.get("spot", 0)); r = float(j.get("r", 0)); q = float(j.get("q", 0))
        if S > 0: return S, r, q
    except Exception: pass
    return None

def _rr_baseline(sym: str, exp_days: int) -> float:
    v = r.hget(RR_BASE_HK.format(sym=sym), str(exp_days))
    try: return float(v) if v is not None else 0.0 # type: ignore
    except Exception: return 0.0

def _now_ms() -> int: return int(time.time() * 1000)

# ============================ EWMA ============================
@dataclass
class EwmaMV:
    mean: float
    var: float
    alpha: float
    def update(self, x: float) -> Tuple[float, float]:
        m0 = self.mean
        self.mean = (1 - self.alpha)*self.mean + self.alpha*x
        self.var  = max(1e-12, (1 - self.alpha)*(self.var + (x - m0)*(x - self.mean)))
        return self.mean, self.var

def _ewma_key(tag: str) -> str:
    return f"ss:ewma:{tag}"

def _load_ewma(tag: str) -> EwmaMV:
    raw = r.get(_ewma_key(tag))
    if raw:
        try:
            o = json.loads(raw) # type: ignore
            return EwmaMV(mean=float(o["m"]), var=float(o["v"]), alpha=float(o.get("a", EWMA_ALPHA)))
        except Exception: pass
    return EwmaMV(mean=0.0, var=1.0, alpha=EWMA_ALPHA)

def _save_ewma(tag: str, ew: EwmaMV) -> None:
    r.set(_ewma_key(tag), json.dumps({"m": ew.mean, "v": ew.var, "a": ew.alpha}))

# ============================ state ============================
@dataclass
class OpenState:
    mode: str
    tag: str
    legs: List[dict]     # [{"sym":..., "side":..., "qty":..., "price":None|float}]
    edge_bps: float
    entry_z: float
    ts_ms: int

def _poskey(name: str, tag: str) -> str:
    return f"ss:open:{name}:{tag}"

# ============================ math: smile fit ============================
def _fit_quadratic_lm(K: List[float], V: List[float], S: float) -> Tuple[float,float,float]:
    """
    Fit IV = a + b*m + c*m^2 with m = ln(K/S).
    Simple least squares (closed form for 3 params).
    """
    m_list = [math.log(max(1e-9, k) / S) for k in K]
    n = len(m_list)
    if n < 3: return sum(V)/n, 0.0, 0.0
    # sums
    s0 = n
    s1 = sum(m_list)
    s2 = sum(x*x for x in m_list)
    s3 = sum(x*x*x for x in m_list)
    s4 = sum(x*x*x*x for x in m_list)
    t0 = sum(V)
    t1 = sum(v*m for v,m in zip(V, m_list))
    t2 = sum(v*(m*m) for v,m in zip(V, m_list))
    # solve 3x3 normal equations
    # |s0 s1 s2| |a| = |t0|
    # |s1 s2 s3| |b|   |t1|
    # |s2 s3 s4| |c|   |t2|
    def det3(a,b,c,d,e,f,g,h,i): return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)
    D  = det3(s0,s1,s2, s1,s2,s3, s2,s3,s4) or 1e-12
    Da = det3(t0,s1,s2, t1,s2,s3, t2,s3,s4)
    Db = det3(s0,t0,s2, s1,t1,s3, s2,t2,s4)
    Dc = det3(s0,s1,t0, s1,s2,t1, s2,s3,t2)
    a = Da/D; b = Db/D; c = Dc/D
    return a,b,c

def _quad_iv(a: float,b: float,c: float, S: float, K: float) -> float:
    m = math.log(max(1e-9, K)/S)
    return max(0.0005, a + b*m + c*m*m)

# ============================ Strategy ============================
class SkewSmileExploitation(Strategy):
    """
    Smile butterflies (vega‑neutral) and 25Δ risk‑reversal skew dislocations.
    """
    def __init__(self, name: str = "skew_smile_exploitation", region: Optional[str] = "GLOBAL", default_qty: float = 1.0):
        super().__init__(name=name, region=region, default_qty=default_qty)
        self._last = 0.0

    def on_tick(self, tick: Dict) -> None:
        if (r.get(HALT_KEY) or "0") == "1": return
        now = time.time()
        if now - self._last < RECHECK_SECS: return
        self._last = now
        if MODE == "BUTTERFLY_SMILE":
            self._eval_butterfly()
        else:
            self._eval_rr()

    # --------------- Smile butterflies ---------------
    def _eval_butterfly(self) -> None:
        meta = _meta(SYM); surf = _surf(SYM, EXP_DAYS)
        if not meta or not surf: return
        S,r,q = meta; K,V = surf
        tag = f"BF:{SYM}:{EXP_DAYS}"

        # Fit quadratic
        a,b,c = _fit_quadratic_lm(K,V,S)
        # Find max residual in vol bps
        residuals = []
        for k, v in zip(K,V):
            v_fit = _quad_iv(a,b,c,S,k)
            res_bps = 1e4 * (v - v_fit)  # + = rich vs fit
            residuals.append((abs(res_bps), res_bps, k, v, v_fit))

        if not residuals: return
        residuals.sort(reverse=True, key=lambda x: x[0])
        top = residuals[0]
        abs_bps, signed_bps, Kc, Vc, Vfit = top

        ew = _load_ewma(tag); m,vv = ew.update(signed_bps); _save_ewma(tag, ew)
        z = (signed_bps - m)/math.sqrt(max(vv,1e-12))

        # monitor
        self.emit_signal(max(-1.0, min(1.0, abs_bps / max(1.0, THRESH_IV_BPS))))

        st = self._load_state(tag)
        if st:
            if (abs(signed_bps) <= EXIT_IV_BPS) or (abs(z) <= EXIT_Z):
                self._close(tag, st)
            return

        if r.get(_poskey(self.ctx.name, tag)) is not None: return # type: ignore
        if not (abs_bps >= THRESH_IV_BPS and abs(z) >= ENTRY_Z): return

        # Choose wings around Kc
        # pick nearest strikes below/above
        K_sorted = sorted(K)
        if Kc not in K_sorted: return
        idx = K_sorted.index(Kc)
        if idx == 0 or idx == len(K_sorted)-1: return
        Kl = K_sorted[idx-1]; Ku = K_sorted[idx+1]

        T = _T(EXP_DAYS)
        # Black vegas for approximate vega-neutral sizing (use calls around ATM; puts share same vega)
        vega_c = _black_vega(S, Kc, T, r, q, Vc, True)
        vega_l = _black_vega(S, Kl, T, r, q, _quad_iv(a,b,c,S,Kl), True)
        vega_u = _black_vega(S, Ku, T, r, q, _quad_iv(a,b,c,S,Ku), True)
        if min(vega_c, vega_l, vega_u) <= 0: return

        # Standard 1:-2:1 fly is near vega‑neutral; scale to USD_NOTIONAL
        # Rough price proxy per option ≈ S * 0.4 * sigma * sqrt(T) (not used for exact)
        px_proxy = S * 0.4 * Vc * math.sqrt(T)
        if px_proxy <= 0: return
        contracts_unit = max(1.0, USD_NOTIONAL / (CONTRACT_MULT * px_proxy))
        qty_w = contracts_unit  # wings
        qty_c = 2.0 * contracts_unit

        legs = []
        if signed_bps > 0:
            # Center rich → SHORT fly: short 2x center, long 1x wings
            legs.append({"sym": f"OPT_CALL:{SYM}:{Kl}:{EXP_DAYS}", "side":"buy",  "qty": qty_w})
            legs.append({"sym": f"OPT_CALL:{SYM}:{Kc}:{EXP_DAYS}", "side":"sell", "qty": qty_c})
            legs.append({"sym": f"OPT_CALL:{SYM}:{Ku}:{EXP_DAYS}", "side":"buy",  "qty": qty_w})
            side_tag = "short_fly"
        else:
            # Center cheap → LONG fly
            legs.append({"sym": f"OPT_CALL:{SYM}:{Kl}:{EXP_DAYS}", "side":"sell", "qty": qty_w})
            legs.append({"sym": f"OPT_CALL:{SYM}:{Kc}:{EXP_DAYS}", "side":"buy",  "qty": qty_c})
            legs.append({"sym": f"OPT_CALL:{SYM}:{Ku}:{EXP_DAYS}", "side":"sell", "qty": qty_w})
            side_tag = "long_fly"

        # Send orders
        for leg in legs:
            self.order(leg["sym"], leg["side"], qty=leg["qty"], order_type="market", venue="OPT")

        self._save_state(tag, OpenState(
            mode="BUTTERFLY_SMILE", tag=f"{side_tag}:{Kl}-{Kc}-{Ku}",
            legs=legs, edge_bps=signed_bps, entry_z=z, ts_ms=_now_ms()
        ))

    # --------------- 25Δ Risk‑Reversal ---------------
    def _eval_rr(self) -> None:
        meta = _meta(SYM); surf = _surf(SYM, EXP_DAYS)
        if not meta or not surf: return
        S,r,q = meta; K,V = surf
        tag = f"RR:{SYM}:{EXP_DAYS}"

        # Compute 25Δ strikes via rough log‑moneyness proxy (Black ’76). We search K with target delta.
        T = _T(EXP_DAYS)

        def call_delta(S,K,T,r,q,sigma):
            if sigma<=0: return 0.5
            f = S*math.exp((r-q)*T)
            vol = sigma*math.sqrt(T)
            d1 = (math.log(f/K) + 0.5*sigma*sigma*T)/max(1e-12,vol)
            return math.exp(-q*T)*_norm_cdf(d1)

        # Use fitted smile to interpolate sigma when searching
        a,b,c = _fit_quadratic_lm(K,V,S)
        def sigma_at(Ki): return _quad_iv(a,b,c,S,Ki)

        Ks = sorted(K)
        # binary search helper to find K s.t. call delta ≈ 0.75 (for +25Δ call) and 0.25 for put (call delta 0.25)
        def k_for_target_delta(target: float) -> Optional[float]:
            lo, hi = Ks[0], Ks[-1]
            for _ in range(40):
                mid = 0.5*(lo+hi)
                d = call_delta(S, mid, T, r, q, sigma_at(mid))
                if d > target: lo = mid
                else: hi = mid
            k = 0.5*(lo+hi)
            return k if Ks[0] <= k <= Ks[-1] else None

        Kc25 = k_for_target_delta(0.75)  # +25Δ call
        Kp25 = k_for_target_delta(0.25)  # ≈ -25Δ put
        if Kc25 is None or Kp25 is None: return

        sig_call = sigma_at(Kc25); sig_put = sigma_at(Kp25)
        rr_bps = 1e4 * (sig_put - sig_call)
        base = _rr_baseline(SYM, EXP_DAYS)
        dev = rr_bps - base

        ew = _load_ewma(tag); m,vv = ew.update(dev); _save_ewma(tag, ew)
        z = (dev - m)/math.sqrt(max(vv,1e-12))

        self.emit_signal(max(-1.0, min(1.0, abs(dev)/max(1.0, THRESH_RR_BPS))))

        st = self._load_state(tag)
        if st:
            if (abs(dev) <= EXIT_RR_BPS) or (abs(z) <= EXIT_Z):
                self._close(tag, st)
            return

        if r.get(_poskey(self.ctx.name, tag)) is not None: return # type: ignore
        if not (abs(dev) >= THRESH_RR_BPS and abs(z) >= ENTRY_Z): return

        # Sizing: proxy premium for 25Δ ≈ 10% of spot * sqrt(T) * sigma
        px_proxy = 0.1 * S * math.sqrt(T) * max(1e-6, 0.5*(sig_call+sig_put))
        contracts = max(1.0, USD_NOTIONAL / max(1e-6, CONTRACT_MULT * px_proxy))

        # Trade: if dev > 0 (put richer than baseline), SELL put / BUY call (short RR); else buy RR
        legs = []
        if dev > 0:
            legs.append({"sym": f"OPT_PUT:{SYM}:{round(Kp25,2)}:{EXP_DAYS}",  "side":"sell", "qty":contracts})
            legs.append({"sym": f"OPT_CALL:{SYM}:{round(Kc25,2)}:{EXP_DAYS}", "side":"buy",  "qty":contracts})
            side_tag = "short_rr"
        else:
            legs.append({"sym": f"OPT_PUT:{SYM}:{round(Kp25,2)}:{EXP_DAYS}",  "side":"buy",  "qty":contracts})
            legs.append({"sym": f"OPT_CALL:{SYM}:{round(Kc25,2)}:{EXP_DAYS}", "side":"sell", "qty":contracts})
            side_tag = "long_rr"

        for leg in legs:
            self.order(leg["sym"], leg["side"], qty=leg["qty"], order_type="market", venue="OPT")

        self._save_state(tag, OpenState(
            mode="RISK_REVERSAL_SKEW", tag=f"{side_tag}:{round(Kp25,2)}vs{round(Kc25,2)}",
            legs=legs, edge_bps=dev, entry_z=z, ts_ms=_now_ms()
        ))

    # --------------- state I/O & close ---------------
    def _load_state(self, tag: str) -> Optional[OpenState]:
        raw = r.get(_poskey(self.ctx.name, tag))
        if not raw: return None
        try:
            o = json.loads(raw) # type: ignore
            return OpenState(mode=str(o["mode"]), tag=str(o["tag"]),
                             legs=list(o.get("legs") or []),
                             edge_bps=float(o["edge_bps"]), entry_z=float(o["entry_z"]),
                             ts_ms=int(o["ts_ms"]))
        except Exception:
            return None

    def _save_state(self, tag: str, st: Optional[OpenState]) -> None:
        if st is None: return
        r.set(_poskey(self.ctx.name, tag), json.dumps({
            "mode": st.mode, "tag": st.tag, "legs": st.legs,
            "edge_bps": st.edge_bps, "entry_z": st.entry_z, "ts_ms": st.ts_ms
        }))

    def _close(self, tag: str, st: OpenState) -> None:
        # Reverse all legs
        for leg in st.legs:
            side = "buy" if leg["side"] == "sell" else "sell"
            self.order(leg["sym"], side, qty=leg["qty"], order_type="market", venue="OPT")
        r.delete(_poskey(self.ctx.name, tag))