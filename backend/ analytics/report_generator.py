# backend/analytics/report_generator.py
from __future__ import annotations

import os, io, json, base64, time, math, datetime as dt
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional, Tuple, Callable

# -------- optional deps (all graceful) ---------------------------------------
try:
    import numpy as np  # charts & stats
except Exception:
    np = None  # type: ignore

try:
    import matplotlib.pyplot as plt  # charts (optional)
    HAVE_MPL = True
except Exception:
    HAVE_MPL = False

# PDF backends (optional)
HAVE_WEASY = True
try:
    from weasyprint import HTML  # type: ignore
except Exception:
    HAVE_WEASY = False

HAVE_PDFKIT = True
try:
    import pdfkit  # type: ignore
except Exception:
    HAVE_PDFKIT = False

# -------- optional redis (graceful) ------------------------------------------
USE_REDIS = True
try:
    from redis import Redis  # type: ignore
except Exception:
    USE_REDIS = False
    Redis = None  # type: ignore

# -------- env / defaults -----------------------------------------------------
REDIS_URL          = os.getenv("REDIS_URL", "redis://localhost:6379/0")
STREAM_PNL         = os.getenv("PNL_STREAM", "pnl.curve")           # {"ts_ms","pnl","cum_pnl","book"?}
STREAM_RISK        = os.getenv("RISK_STREAM", "risk.metrics")       # {"ts_ms","book","vol_20d","drawdown_pct","es_975","delta_book"}
STREAM_VAR         = os.getenv("INTRADAY_VAR_STREAM", "risk.intraday_var") # {"ts_ms","symbol","var_ewma","var_hist"}
STREAM_REGIME      = os.getenv("REGIME_OUT_STREAM", "regime.state") # {"ts_ms","regime","score","features":{...}}
STREAM_POSITIONS   = os.getenv("POSITIONS_STREAM", "positions.snapshots")
STREAM_ALERTS      = os.getenv("ALERTS_STREAM", "alerts.events")    # {"ts_ms","level","msg","context":{...}}

ARTIFACT_DIR       = os.getenv("REPORT_DIR", "artifacts/reports")
os.makedirs(ARTIFACT_DIR, exist_ok=True)

# -------- small utils --------------------------------------------------------
def now_ms() -> int: return int(time.time() * 1000)
def ts_to_str(ts_ms: int, tz: str = "UTC") -> str:
    return dt.datetime.utcfromtimestamp(ts_ms/1000).strftime("%Y-%m-%d %H:%M:%S") + "Z"

def _b64_png(fig) -> str:
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight")
    plt.close(fig)
    return base64.b64encode(buf.getvalue()).decode("ascii")

def _fmt_pct(x: Optional[float]) -> str:
    try:
        return f"{100.0*float(x):.2f}%" # type: ignore
    except Exception:
        return "—"

def _fmt(x: Optional[float], nd=4) -> str:
    try:
        return f"{float(x):.{nd}f}" # type: ignore
    except Exception:
        return "—"

# -------- data shapes --------------------------------------------------------
@dataclass
class SectionConfig:
    title: str
    enabled: bool = True

@dataclass
class ReportConfig:
    title: str = "Daily Trading Report"
    subtitle: str = "Auto-generated by analytics/report_generator"
    lookback_minutes: int = 24*60
    include_sections: Dict[str, SectionConfig] = None  # type: ignore # filled below
    to_pdf: bool = False
    theme: str = "dark"  # "dark" | "light"

    def __post_init__(self):
        if self.include_sections is None:
            self.include_sections = {
                "overview": SectionConfig("Executive Overview", True),
                "pnl": SectionConfig("PnL Curve & Attribution", True),
                "risk": SectionConfig("Risk Metrics & Limits", True),
                "var": SectionConfig("Intraday VaR", True),
                "regime": SectionConfig("Regime State", True),
                "positions": SectionConfig("Top Positions & Exposures", True),
                "alerts": SectionConfig("Alerts (last 24h)", True),
            }

# -------- sources interface --------------------------------------------------
class Source:
    """Abstracts where we load data from: Redis streams or files/callables."""
    def load(self, lookback_ms: int) -> Dict[str, Any]:
        raise NotImplementedError

class RedisSource(Source):
    def __init__(self, url: str = REDIS_URL, maxlen: int = 5000):
        if not USE_REDIS:
            raise RuntimeError("redis-py not available.")
        self.r = Redis.from_url(url, decode_responses=True)  # type: ignore
        self.maxlen = maxlen

    def _xrange_latest(self, stream: str, start_ms: int) -> List[Dict[str, Any]]:
        out: List[Dict[str, Any]] = []
        start_id = f"{int(start_ms)}-0"
        try:
            for _id, fields in self.r.xrange(stream, min=start_id, max="+", count=self.maxlen):  # type: ignore
                j = {}
                try:
                    j = json.loads(fields.get("json", "{}"))
                except Exception:
                    continue
                out.append(j)
        except Exception:
            # stream may not exist; ignore
            pass
        return out

    def load(self, lookback_ms: int) -> Dict[str, Any]:
        start = now_ms() - lookback_ms
        return {
            "pnl":      self._xrange_latest(STREAM_PNL, start),
            "risk":     self._xrange_latest(STREAM_RISK, start),
            "var":      self._xrange_latest(STREAM_VAR, start),
            "regime":   self._xrange_latest(STREAM_REGIME, start),
            "positions":self._xrange_latest(STREAM_POSITIONS, start),
            "alerts":   self._xrange_latest(STREAM_ALERTS, start),
        }

class FilesSource(Source):
    """
    Provide paths or callables per key -> list[dict]. Each dict should match the shapes in Redis.
    """
    def __init__(self, loaders: Dict[str, Callable[[], List[Dict[str, Any]]]] | Dict[str, str]):
        self.loaders = loaders

    def load(self, lookback_ms: int) -> Dict[str, Any]:
        out: Dict[str, Any] = {}
        for k, v in self.loaders.items():
            if callable(v):
                try:
                    out[k] = v() or []
                except Exception:
                    out[k] = []
            else:
                # assume JSON file (list of dicts)
                try:
                    with open(v, "r") as f:
                        out[k] = json.load(f) or []
                except Exception:
                    out[k] = []
        return out

# -------- renderers ----------------------------------------------------------
class Renderer:
    def __init__(self, cfg: ReportConfig):
        self.cfg = cfg

    def render(self, data: Dict[str, Any]) -> str:
        # inline CSS (dark/light toggle)
        palette = {
            "dark":  {"bg":"#0b0f14","fg":"#e6edf3","muted":"#9fb1c1","card":"#121822","acc":"#6ea8fe","warn":"#ffcf5c","bad":"#ff7b72","good":"#3fb950"},
            "light": {"bg":"#ffffff","fg":"#111827","muted":"#6b7280","card":"#f3f4f6","acc":"#2563eb","warn":"#b45309","bad":"#b91c1c","good":"#047857"},
        }[self.cfg.theme]

        css = f"""
        body{{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:{palette['bg']};color:{palette['fg']};}}
        .wrap{{padding:28px 28px 80px 28px;max-width:1200px;margin:0 auto;}}
        h1{{margin:0 0 6px 0;font-size:28px}}
        h2{{margin:24px 0 10px 0;font-size:20px;border-bottom:1px solid {palette['card']};padding-bottom:6px}}
        .sub{{color:{palette['muted']};font-size:13px;margin-bottom:20px}}
        .grid{{display:grid;grid-template-columns:repeat(12,1fr);gap:14px}}
        .card{{background:{palette['card']};border-radius:12px;padding:14px}}
        .span6{{grid-column:span 6}}
        .span12{{grid-column:span 12}}
        table{{width:100%;border-collapse:collapse;font-size:13px}}
        th,td{{padding:8px;border-bottom:1px solid rgba(255,255,255,0.05)}}
        th{{text-align:left;color:{palette['muted']};font-weight:600}}
        .kpi{{display:flex;gap:16px;flex-wrap:wrap}}
        .kpi .tile{{background:{palette['card']};border-radius:10px;padding:12px 14px}}
        .ok{{color:{palette['good']}}}
        .warn{{color:{palette['warn']}}}
        .bad{{color:{palette['bad']}}}
        img.chart{{width:100%;border-radius:10px;}}
        code.small{{font-size:12px;color:{palette['muted']}}}
        """

        # assemble sections
        sections: List[str] = []
        include = self.cfg.include_sections

        # ---- Overview
        if include["overview"].enabled:
            ov = _overview_block(data)
            sections.append(f"""
                <div class="card span12">
                  <h2>{include["overview"].title}</h2>
                  {ov}
                </div>
            """)

        # ---- PnL
        if include["pnl"].enabled:
            pnl_html = _pnl_block(data)
            sections.append(f'<div class="card span12"><h2>{include["pnl"].title}</h2>{pnl_html}</div>')

        # ---- Risk
        if include["risk"].enabled:
            risk_html = _risk_block(data)
            sections.append(f'<div class="card span6">{risk_html}</div>')

        # ---- Intraday VaR
        if include["var"].enabled:
            var_html = _var_block(data)
            sections.append(f'<div class="card span6">{var_html}</div>')

        # ---- Regime
        if include["regime"].enabled:
            reg_html = _regime_block(data)
            sections.append(f'<div class="card span6">{reg_html}</div>')

        # ---- Positions
        if include["positions"].enabled:
            pos_html = _positions_block(data)
            sections.append(f'<div class="card span6">{pos_html}</div>')

        # ---- Alerts
        if include["alerts"].enabled:
            al_html = _alerts_block(data)
            sections.append(f'<div class="card span12">{al_html}</div>')

        # shell
        stamp = dt.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S") + "Z"
        html = f"""
        <!doctype html><html><head><meta charset="utf-8">
        <title>{self.cfg.title}</title>
        <style>{css}</style></head>
        <body><div class="wrap">
          <h1>{self.cfg.title}</h1>
          <div class="sub">{self.cfg.subtitle} • Generated {stamp}</div>
          <div class="grid">{''.join(sections)}</div>
          <div style="margin-top:20px"><code class="small">analytics/report_generator.py</code></div>
        </div></body></html>
        """
        return html

# -------- section builders ---------------------------------------------------
def _overview_block(data: Dict[str, Any]) -> str:
    # last regime, last risk, last pnl
    regime = data.get("regime", [])
    risk   = data.get("risk", [])
    pnl    = data.get("pnl", [])

    reg = (regime[-1] if regime else {})
    rsk = (risk[-1] if risk else {})
    p   = (pnl[-1] if pnl else {})

    items = [
        ("Regime", reg.get("regime","—")),
        ("Regime score", _fmt(reg.get("score"), 3)),
        ("Vol (20d)", _fmt(rsk.get("vol_20d"), 4)),
        ("Drawdown", _fmt_pct(rsk.get("drawdown_pct"))),
        ("ES 97.5%", _fmt(rsk.get("es_975"), 4)),
        ("PnL (last)", _fmt(p.get("pnl"), 2)),
        ("Cum PnL", _fmt(p.get("cum_pnl"), 2)),
    ]
    chips = "".join([f'<div class="tile"><div style="font-size:12px;color:#9fb1c1">{k}</div><div style="font-size:18px;font-weight:700">{v}</div></div>' for k,v in items])
    return f'<div class="kpi">{chips}</div>'

def _pnl_block(data: Dict[str, Any]) -> str:
    rows = data.get("pnl", []) or []
    if not rows:
        return "<em>No PnL data.</em>"
    ts = [r.get("ts_ms") for r in rows if r.get("ts_ms") is not None]
    pnl = [float(r.get("pnl") or 0.0) for r in rows]
    cum = [float(r.get("cum_pnl") or 0.0) for r in rows]

    chart = ""
    if HAVE_MPL and np is not None and len(ts) > 1:
        fig = plt.figure(figsize=(9,3))
        ax = fig.add_subplot(111)
        ax.plot(cum, label="Cum PnL")
        ax.plot(pnl, alpha=0.5, label="PnL")
        ax.grid(True, alpha=0.2); ax.legend(loc="best", fontsize=8)
        ax.set_xlabel("Ticks"); ax.set_ylabel("PnL")
        chart = f'<img class="chart" src="data:image/png;base64,{_b64_png(fig)}" />'

    table_rows = "".join([f"<tr><td>{ts_to_str(t)}</td><td>{_fmt(pnl[i],2)}</td><td>{_fmt(cum[i],2)}</td></tr>" for i,t in enumerate(ts[-20:])])
    table = f"<table><thead><tr><th>Time</th><th>PnL</th><th>Cumulative</th></tr></thead><tbody>{table_rows}</tbody></table>"
    return f"<h2>PnL</h2>{chart}{table}"

def _risk_block(data: Dict[str, Any]) -> str:
    rows = data.get("risk", []) or []
    if not rows:
        return "<h2>Risk</h2><em>No risk metrics.</em>"
    last = rows[-1]
    table_rows = "".join([
        f"<tr><td>Vol (20d)</td><td>{_fmt(last.get('vol_20d'),4)}</td></tr>",
        f"<tr><td>Drawdown</td><td>{_fmt_pct(last.get('drawdown_pct'))}</td></tr>",
        f"<tr><td>Expected Shortfall 97.5%</td><td>{_fmt(last.get('es_975'),4)}</td></tr>",
        f"<tr><td>Book Delta</td><td>{_fmt(last.get('delta_book'),2)}</td></tr>",
    ])
    return f"<h2>Risk</h2><table><tbody>{table_rows}</tbody></table>"

def _var_block(data: Dict[str, Any]) -> str:
    rows = [r for r in (data.get("var", []) or []) if r.get("symbol")]
    if not rows:
        return "<h2>Intraday VaR</h2><em>No VaR snapshots.</em>"
    # pick most frequent symbol or portfolio None
    syms = {}
    for r in rows:
        s = r.get("symbol") or "PORT"
        syms[s] = syms.get(s, 0) + 1
    top = sorted(syms.items(), key=lambda x: -x[1])[0][0]
    series = [r for r in rows if (r.get("symbol") or "PORT")==top][-200:]

    var_e = [r.get("var_ewma") for r in series]
    var_h = [r.get("var_hist") for r in series]

    chart = ""
    if HAVE_MPL and np is not None and len(series) > 2:
        fig = plt.figure(figsize=(6,3))
        ax = fig.add_subplot(111)
        ax.plot(var_e, label="EWMA VaR")
        if any(v is not None for v in var_h): ax.plot(var_h, alpha=0.6, label="Hist VaR")
        ax.set_title(f"Intraday VaR ({top})"); ax.grid(True, alpha=0.2); ax.legend(fontsize=8)
        ax.set_ylabel("Loss (return units)")
        chart = f'<img class="chart" src="data:image/png;base64,{_b64_png(fig)}" />'
    t_last = series[-1].get("ts_ms")
    tbl = f"<table><tbody><tr><td>Latest symbol</td><td>{top}</td></tr><tr><td>Latest time</td><td>{ts_to_str(t_last)}</td></tr><tr><td>EWMA VaR (last)</td><td>{_fmt(var_e[-1],4)}</td></tr></tbody></table>"
    return f"<h2>Intraday VaR</h2>{chart}{tbl}"

def _regime_block(data: Dict[str, Any]) -> str:
    rows = data.get("regime", []) or []
    if not rows:
        return "<h2>Regime</h2><em>No regime data.</em>"
    last = rows[-1]
    feats = last.get("features") or {}
    table_rows = "".join([
        f"<tr><td>Regime</td><td>{last.get('regime','—')}</td></tr>",
        f"<tr><td>Score</td><td>{_fmt(last.get('score'),3)}</td></tr>",
        f"<tr><td>rv</td><td>{_fmt(feats.get('rv'),4)}</td></tr>",
        f"<tr><td>tr</td><td>{_fmt(feats.get('tr'),3)}</td></tr>",
        f"<tr><td>corr</td><td>{_fmt(feats.get('corr'),3)}</td></tr>",
        f"<tr><td>liq</td><td>{_fmt(feats.get('liq'),3)}</td></tr>",
        f"<tr><td>cred</td><td>{_fmt(feats.get('cred'),3)}</td></tr>",
        f"<tr><td>Notes</td><td>{(last.get('notes') or '—')}</td></tr>",
    ])
    return f"<h2>Regime</h2><table><tbody>{table_rows}</tbody></table>"

def _positions_block(data: Dict[str, Any]) -> str:
    snaps = data.get("positions", []) or []
    if not snaps:
        return "<h2>Positions</h2><em>No snapshots.</em>"
    last = snaps[-1]
    pos = last.get("positions") or []
    prices = last.get("prices") or {}
    # compute top notionals
    rows = []
    for p in pos:
        s = str(p.get("symbol","")).upper()
        q = float(p.get("qty") or 0.0)
        px = float(prices.get(s, 0.0) or 0.0)
        notional = abs(q) * px
        rows.append((s, q, px, notional))
    top = sorted(rows, key=lambda x: -x[3])[:12]
    body = "".join([f"<tr><td>{s}</td><td>{_fmt(q,2)}</td><td>{_fmt(px,2)}</td><td>{_fmt(n,2)}</td></tr>" for (s,q,px,n) in top])
    return f"<h2>Top Positions</h2><table><thead><tr><th>Symbol</th><th>Qty</th><th>Price</th><th>Notional</th></tr></thead><tbody>{body}</tbody></table>"

def _alerts_block(data: Dict[str, Any]) -> str:
    alerts = data.get("alerts", []) or []
    if not alerts:
        return "<h2>Alerts (24h)</h2><em>No alerts.</em>"
    rows = alerts[-25:]
    body = "".join([
        f"<tr><td>{ts_to_str(r.get('ts_ms', now_ms()))}</td><td>{(r.get('level') or 'info').upper()}</td><td>{(r.get('msg') or '')}</td></tr>"
        for r in rows
    ])
    return f"<h2>Alerts (24h)</h2><table><thead><tr><th>Time</th><th>Level</th><th>Message</th></tr></thead><tbody>{body}</tbody></table>"

# -------- public API ---------------------------------------------------------
def generate_report(
    *,
    cfg: Optional[ReportConfig] = None,
    source: Optional[Source] = None,
    out_basename: Optional[str] = None
) -> Dict[str, str]:
    """
    Renders an HTML report (and PDF if configured) to artifacts/reports/.
    Returns dict with {"html": path, "pdf": path?}
    """
    cfg = cfg or ReportConfig()
    lookback_ms = cfg.lookback_minutes * 60 * 1000
    source = source or (RedisSource() if USE_REDIS else FilesSource({}))
    data = source.load(lookback_ms)

    html = Renderer(cfg).render(data)

    stamp = dt.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    base = out_basename or f"report_{stamp}"
    html_path = os.path.join(ARTIFACT_DIR, f"{base}.html")
    with open(html_path, "w", encoding="utf-8") as f:
        f.write(html)

    out: Dict[str, str] = {"html": html_path}

    if cfg.to_pdf:
        pdf_path = os.path.join(ARTIFACT_DIR, f"{base}.pdf")
        if HAVE_WEASY:
            try:
                HTML(filename=html_path).write_pdf(pdf_path)  # type: ignore
                out["pdf"] = pdf_path
            except Exception:
                pass
        elif HAVE_PDFKIT:
            try:
                pdfkit.from_file(html_path, pdf_path)  # requires wkhtmltopdf
                out["pdf"] = pdf_path
            except Exception:
                pass
    return out

# -------- CLI ----------------------------------------------------------------
def _cli():
    import argparse
    ap = argparse.ArgumentParser("report_generator")
    ap.add_argument("--from-streams", action="store_true", help="Pull from Redis streams (default if redis available).")
    ap.add_argument("--from-files", type=str, nargs="*", help="Key=path pairs, e.g., pnl=pnl.json risk=risk.json ...")
    ap.add_argument("--minutes", type=int, default=24*60, help="Lookback minutes")
    ap.add_argument("--title", type=str, default="Daily Trading Report")
    ap.add_argument("--subtitle", type=str, default="Automated report")
    ap.add_argument("--theme", type=str, default="dark", choices=["dark","light"])
    ap.add_argument("--pdf", action="store_true", help="Also create PDF (if weasyprint/pdfkit available)")
    ap.add_argument("--basename", type=str, default=None, help="Output base filename (without extension)")
    args = ap.parse_args()

    cfg = ReportConfig(title=args.title, subtitle=args.subtitle, lookback_minutes=args.minutes, to_pdf=args.pdf, theme=args.theme)

    if args.from_files:
        mapping: Dict[str, str] = {}
        for kv in args.from_files:
            if "=" in kv:
                k, v = kv.split("=", 1)
                mapping[k.strip()] = v.strip()
        src = FilesSource(mapping)
    else:
        if not USE_REDIS and not args.from_files:
            print("redis not available; provide --from-files key=path ..."); return
        src = RedisSource()

    out = generate_report(cfg=cfg, source=src, out_basename=args.basename)
    print("HTML:", out.get("html"))
    if out.get("pdf"):
        print("PDF :", out.get("pdf"))

if __name__ == "__main__":
    _cli()